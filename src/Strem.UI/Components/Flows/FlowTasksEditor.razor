@using Strem.Core.Flows
@using Strem.Core.Flows.Registries.Tasks
@using Strem.Core.Flows.Tasks
@using Strem.Core.Extensions
@using Strem.Core.Events.Bus
@using Strem.Core.Events.Flows.Tasks
@using System.Reactive.Disposables
@using System.Reactive.Linq
@using Strem.Core.Types

@inject ITaskRegistry TaskRegistry
@inject IEventBus EventBus
@inject DragController DragController

@implements IDisposable

@foreach (var data in TaskData)
{
    <DraggableListElement Data="data" DropType="@DropTypes.FlowTask" ContainingList="TaskData" SupportedDropTypes="@(new []{ DropTypes.FlowTask, DropTypes.NewTask })">
        <TaskComponent Data="data" ComponentType="GetComponentFor(data)" IsRunning="@(ActiveTaskId == data.Id)"
                               OnRequestedDeletion="RemoveTaskData" Task="GetTaskFor(data)"/>
    </DraggableListElement>

    if (data is IHasSubTaskData subTaskData && subTaskData.SubTaskKeys.Length > 0)
    {
        foreach (var subKey in subTaskData.SubTaskKeys)
        {
            <ul class="sub-tasks">
                <p class="menu-label">@subKey</p>
                <FlowTaskEditor TaskData="@subTaskData.SubTasks[subKey]" />
            </ul>
        }
    }
}

@code {
    [Parameter]
    public List<IFlowTaskData> TaskData { get; set; }
    
    public Type GetComponentFor(IFlowTaskData data) => TaskRegistry.Get(data.Code).ComponentType;
    public IFlowTask GetTaskFor(IFlowTaskData data) => TaskRegistry.Get(data.Code).Task;

    public Guid ActiveTaskId { get; set; }
  
    private CompositeDisposable _subs = new();

    protected override async Task OnInitializedAsync()
    {
        DragController.OnDroppedItem
            .Where(x => x.SourceDropType == DropTypes.FlowTask && x.DestinationDropType == DropTypes.FlowTask)
            .Subscribe(MoveTaskElement)
            .AddTo(_subs);
        
        DragController.OnDroppedItem
            .Where(x => x.SourceDropType == DropTypes.NewTask && x.DestinationDropType == DropTypes.FlowTask)
            .Subscribe(AddNewTask)
            .AddTo(_subs);
    }

    public void RemoveTaskData(IFlowTaskData data)
    {
        TaskData.Remove(data);
    }

    public void MoveTaskElement(DropData args)
    {
        args.SourceList.Remove(args.SourceObject);
        var indexToAddAt = args.DestinationList.IndexOf(args.DestinationObject);
        if (indexToAddAt == -1) { indexToAddAt = 0; }
        args.DestinationList.Insert(indexToAddAt, args.SourceObject);

        InvokeAsync(StateHasChanged);
    }

    public void AddNewTask(DropData args)
    {
        var indexToAddAt = args.DestinationList.IndexOf(args.DestinationObject);
        if (indexToAddAt == -1) { indexToAddAt = 0; }
        var taskDescriptor = args.SourceObject as TaskDescriptor;
        if(taskDescriptor == null) { return; }

        var newTaskData = taskDescriptor.Data();
        args.DestinationList.Insert(indexToAddAt, newTaskData);
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    { _subs?.Dispose(); }
}