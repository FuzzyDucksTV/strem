@using Strem.Core.Flows
@using Strem.Core.Flows.Registries.Tasks
@using Strem.Core.Flows.Tasks
@using Strem.Core.Extensions
@using Strem.Core.Events.Bus
@using Strem.Core.Events.Flows.Tasks
@using System.Reactive.Disposables
@using System.Reactive.Linq

@inject ITaskRegistry TaskRegistry;
@inject IEventBus EventBus;

@implements IDisposable

@foreach (var data in TaskData)
{
    <li draggable="true"
        class="block @(DragEnter?.Id == data.Id ? "drag-enter-target" : "")"
        @key=@data.Id
        id="@data.Id"
        ondragover="event.preventDefault()"
        @ondragstart="@(() => OnDragStart(data))"
        @ondrop="@(() => OnDropOverElement(data))"
        @ondragenter="@(() => OnDragEnterElement(data))"
        @ondragend="OnDragEnd">
    
        <TaskComponent Data="data" ComponentType="GetComponentFor(data)" IsRunning="@(ActiveTaskId == data.Id)"
                       OnRequestedDeletion="RemoveTaskData" Task="GetTaskFor(data)"/>
    </li>
    
    if (data is IHasSubTaskData subTaskData && subTaskData.SubTaskKeys.Length > 0)
    {
        foreach (var subKey in subTaskData.SubTaskKeys)
        {
            <ul class="sub-tasks">
                <p class="menu-label">@subKey</p>
                <FlowTaskEditor TaskData="@subTaskData.SubTasks[subKey]" />
            </ul>
        }
    }
}

@code {
    [Parameter]
    public List<IFlowTaskData> TaskData { get; set; }
    
    public Type GetComponentFor(IFlowTaskData data) => TaskRegistry.Get(data.Code).ComponentType;
    public IFlowTask GetTaskFor(IFlowTaskData data) => TaskRegistry.Get(data.Code).Task;

    public Guid ActiveTaskId { get; set; }
  
    private IFlowTaskData? DraggedItem;
    private int DraggedItemIndex;
    private IFlowTaskData? DragEnter;
    private CompositeDisposable _subs = new();

    public void RemoveTaskData(IFlowTaskData data)
    {
        TaskData.Remove(data);
    }
    
    protected override Task OnInitializedAsync()
    {
        // TODO Find a nice way of handling this, possibly a local queue we add to and process on a separate observable
        /*
        EventBus.Receive<FlowTaskStarted>()
            .Subscribe(x =>
            {
                ActiveTaskId = x.TaskId;
                InvokeAsync(StateHasChanged);
            })
            .AddTo(_subs);
      
        EventBus.Receive<FlowTaskFinished>()
            .Delay(TimeSpan.FromSeconds(1))
            .Subscribe(x =>
            {
                ActiveTaskId = Guid.Empty;
                InvokeAsync(StateHasChanged);
            })
            .AddTo(_subs);
        */
        return base.OnInitializedAsync();
    }
  
    public void OnDropOverElement(IFlowTaskData dropTarget)
    {
        DragEnter=null;
        if (DraggedItem == null) return;
        if (DraggedItem == dropTarget) return;
        
        var friendIndex = TaskData.IndexOf(dropTarget);
        TaskData.Swap(friendIndex, DraggedItemIndex);
        DraggedItem=null;
    }

    public void  OnDragStart(IFlowTaskData item)
    {
        DraggedItem = item;
        DraggedItemIndex = TaskData.IndexOf(item);
    }

    public void OnDragEnterElement(IFlowTaskData item)
    {
        if (DraggedItem == null) { return; }
        DragEnter = item;
    }

    public void  OnDragEnd()
    {
        DraggedItem = null;        
        DragEnter = null;
    }

    public void Dispose()
    {
        _subs?.Dispose();
    }

}