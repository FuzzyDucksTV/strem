@using System.Reactive.Disposables
@using Persistity.Extensions
@using Strem.Core.State
@using Strem.Discord.Events.OAuth
@using Strem.Core.Events.Bus
@using Strem.Core.Extensions
@using Strem.Discord.Extensions
@using Strem.Discord.Services.Client
@using Strem.Discord.Services.OAuth
@using Strem.Discord.Types

@implements IDisposable

@inject IEventBus EventBus
@inject IAppState AppState
@inject IDiscordOAuthClient OAuthClient
@inject IDiscordServiceClient ServiceClient

<div class="columns">
    
    <div class="column">
        <label class="label">Connected Account</label>
        <div class="field has-addons">
            <div class="control is-expanded">
                <input class="input" type="text" placeholder="Account Not Linked" value="@Username" disabled/>
            </div>
            <div class="control">
                @if (IsDiscordAccountLinked && !HavePermissionsChanged)
                {
                    <a class="button is-danger" @onclick="DisconnectFromDiscord">Disconnect From Discord</a>
                }
                else if (IsDiscordAccountLinked && HavePermissionsChanged)
                {
                    <a class="button is-warning" @onclick="ConnectToDiscord">Request New Permissions</a>
                }
                else
                {
                    <a class="button is-success" @onclick="ConnectToDiscord">Connect To Discord</a>
                }
            </div>
        </div>
    </div>
</div>
<DiscordScopes ExistingScopes="CurrentScopes" OnScopesChanged="RequestNewScopeAccess" />

<button class="button is-danger" @onclick="SendMessage">SEND MESSAGE</button>

@code {
    public bool IsDiscordAccountLinked { get; set; }
    public bool HavePermissionsChanged { get; set; }
    public string[] CurrentScopes { get; set; } = Array.Empty<string>();
    public string[] NewScopes { get; set; } = Array.Empty<string>();
    public string Username { get; set; }
    
    private CompositeDisposable _subs = new();
    
    protected override async Task OnInitializedAsync()
    {
        IsDiscordAccountLinked = AppState.HasDiscordOAuth();

        if (IsDiscordAccountLinked)
        {
            CurrentScopes = AppState.GetDiscordScopes();
            NewScopes = CurrentScopes.ToArray();
        }
        
        EventBus.Receive<DiscordOAuthSuccessEvent>()
            .Subscribe(x =>
            {
                IsDiscordAccountLinked = true;
                InvokeAsync(StateHasChanged);
            })
            .AddTo(_subs);        
        
        EventBus.Receive<DiscordOAuthRevokedEvent>()
            .Subscribe(x =>
            {
                IsDiscordAccountLinked = false;
                InvokeAsync(StateHasChanged);
            })
            .AddTo(_subs);
    }

    public void ConnectToDiscord()
    {
        var totalScopes = new List<string>(NewScopes);
        if(!totalScopes.Contains(ApiScopes.Identify)){ totalScopes.Add(ApiScopes.Identify); }
        OAuthClient.StartAuthorisationProcess(totalScopes.ToArray());
    }
    
    public async Task DisconnectFromDiscord()
    {
        await OAuthClient.RevokeToken();
        InvokeAsync(StateHasChanged);
    }

    public void RequestNewScopeAccess(string[] newScopes)
    {
        NewScopes = newScopes;
        HavePermissionsChanged = true;
    }
        
    public void Dispose()
    {
        _subs?.Dispose();  
    }

    private async Task SendMessage()
    {
        if(!ServiceClient.IsConnected) { return; }
        await ServiceClient.SendMessage("This is a test", "grofit-general");
    }

}